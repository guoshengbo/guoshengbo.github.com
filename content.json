{"meta":{"title":"郭","subtitle":null,"description":null,"author":"guoshengbo","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2019-02-27T08:06:07.000Z","updated":"2020-11-13T03:06:53.090Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"郭的小窝 介绍姓名：郭出生年月：1993年10月爱好：电子产品职业：前端 2020学习计划1、学位英语2、TypeScript学习3、Vue3.0学习以及Vue2.0/3.0源码学习4、rect的掌握了解5、持续关注flutter的发展 联系方式guoshengbo@vip.qq.com"},{"title":"","date":"2020-11-13T03:06:53.092Z","updated":"2020-11-13T03:06:53.092Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":"Aurora一个基于 Vue 开发的 SPA 单页面博客应用程序，使用 Github Issues 进行写作，借助 Github Api 获取数据。博客评论系统采用开源项目 Gitalk，同时使用 valine 作为游客评论系统。"}],"posts":[{"title":"原生js获取用户IP&根据浏览器生成唯一uuid","slug":"原生js获取用户IP&根据浏览器生成唯一uuid","date":"2020-10-04T03:07:28.000Z","updated":"2020-11-13T09:42:36.924Z","comments":true,"path":"2020/10/04/原生js获取用户IP&根据浏览器生成唯一uuid/","link":"","permalink":"http://yoursite.com/2020/10/04/原生js获取用户IP&根据浏览器生成唯一uuid/","excerpt":"","text":"1、通过RTCPeerConnection获取用户ip关于RTCPeerConnection兼容情况 12345678910111213141516171819202122232425262728293031323334353637383940414243function getUserIP(onNewIP) &#123; // onNewIp - your listener function for new IPs //compatibility for firefox and chrome var myPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection; var pc = new myPeerConnection(&#123; iceServers: [] &#125;), noop = function() &#123;&#125;, localIPs = &#123;&#125;, ipRegex = /([0-9]&#123;1,3&#125;(\\.[0-9]&#123;1,3&#125;)&#123;3&#125;|[a-f0-9]&#123;1,4&#125;(:[a-f0-9]&#123;1,4&#125;)&#123;7&#125;)/g, key; function iterateIP(ip) &#123; if (!localIPs[ip]) onNewIP(ip); localIPs[ip] = true; &#125; //create a bogus data channel pc.createDataChannel(&quot;&quot;); // create offer and set local description pc.createOffer().then(function(sdp) &#123; sdp.sdp.split(&apos;\\n&apos;).forEach(function(line) &#123; if (line.indexOf(&apos;candidate&apos;) &lt; 0) return; line.match(ipRegex).forEach(iterateIP); &#125;); pc.setLocalDescription(sdp, noop, noop); &#125;).catch(function(reason) &#123; // An error occurred, so handle the failure to connect &#125;); //sten for candidate events pc.onicecandidate = function(ice) &#123; if (!ice || !ice.candidate || !ice.candidate.candidate || !ice.candidate.candidate.match(ipRegex)) return; ice.candidate.candidate.match(ipRegex).forEach(iterateIP); &#125;;&#125; // Usage getUserIP(function(ip)&#123; alert(&quot;Got IP! :&quot; + ip);&#125;); 2、根据浏览器生成唯一uuid安装依赖库1npm install fingerprintjs 使用1var fingerprint = new Fingerprint().get(); 如果你想使用 Canvas FingerPrinting，则如下调用：1var fingerprint = new Fingerprint(&#123;canvas: true&#125;).get(); 如果你想使用屏幕分辨率计算指纹，则需如下调用：1var fingerprint = new Fingerprint(&#123;screen_resolution: true&#125;).get(); 使用自定义的哈希函数12var my_hasher = new function(value, seed)&#123; return value.length % seed; &#125;;var fingerprint = new Fingerprint(&#123;hasher: my_hasher&#125;).get(); 或者直接传递方法：12var my_hasher = new function(value, seed)&#123; return value.length % seed; &#125;;var fingerprint = new Fingerprint(my_hasher).get(); 更新（跨浏览器识别）一项可以跨浏览器获取唯一识别码的技术通过不同算法，让浏览器进行一系列计算，最后根据不同的场景和计算过程中的纹路信息得出唯一识别码（其核心概念在于硬件的唯一性） demo 论文地址","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"},{"name":"IP","slug":"IP","permalink":"http://yoursite.com/tags/IP/"},{"name":"UUID","slug":"UUID","permalink":"http://yoursite.com/tags/UUID/"},{"name":"cross_browser","slug":"cross-browser","permalink":"http://yoursite.com/tags/cross-browser/"}]},{"title":"forEach和map会修改原素组？","slug":"forEach和map会修改原素组？","date":"2020-02-15T06:42:05.000Z","updated":"2021-04-15T12:19:35.511Z","comments":true,"path":"2020/02/15/forEach和map会修改原素组？/","link":"","permalink":"http://yoursite.com/2020/02/15/forEach和map会修改原素组？/","excerpt":"","text":"forEach() 方法不会返回执行结果, 而是 undefined. 也就是说, forEach() 会修改原来的数组. 而 map() 方法会得到一个新的数组并返回. 我的理解就是使用 forEach 遍历一个数组, 修改 item 的值, 就会改变原数组, 但最近发现并不一定会改变, 所以就做了一些测试 forEach 1234567891011let arr= [ &#123;a:1,b:2&#125;, &#123;a:3,b:4&#125;]arr.forEach(item=&gt;&#123; item.a = 5&#125;)// arr 变成了[// &#123;a:5,b:2&#125;,// &#123;a:5,b:4&#125;// ] map 12345678910111213let arr1=arr.map(item=&gt;&#123; item.b = 6 return item&#125;)// arr 变成了[// &#123;a:5,b:6&#125;,// &#123;a:5,b:6&#125;// ]// arr1 值是[// &#123;a:5,b:6&#125;,// &#123;a:5,b:6&#125;// ] arr 这个原数组的值为什么也改变了呢? 在网上搜了一下, 原来是上面的 map 方法不够 “纯粹”, 实际上还是直接修改了每个 item 的属性, 要想不影响原有对象, 应该这么写: 1234567891011121314arr1 = arr.map(item=&gt;&#123; ...item, b:7&#125;)// arr 是[// &#123;a:5,b:6&#125;,// &#123;a:5,b:6&#125;// ]// arr1 值是[// &#123;a:5,b:7&#125;,// &#123;a:5,b:7&#125;// ] 这样就不影响原数组了 上面的测试都是修改原数组中某一个对象的某一个属性, 那如果直接修改数组的某一个对象呢? 12345678910111213141516171819202122arr.forEach(item=&gt;&#123; item = 5&#125;)// arr 是[// &#123;a:5,b:6&#125;,// &#123;a:5,b:6&#125;// ]arr1 = arr.map(item=&gt;&#123; item = 5&#125;)// arr 是[// &#123;a:5,b:6&#125;,// &#123;a:5,b:6&#125;// ]// arr1 值是[// 5,// 5// ] 发现原数组都没有改变 原理 不论是 forEach 还是 map, 所传入的 item 都是原数组所对应的对象的地址值, 当你修改 item 某一个属性后, 指向这个 item 对应的地址值的所有对象都会改变, 就会出现测试一的结果; 但如果你直接将 item 重新赋值, 那 item 就和原数组所对应的对象没有关系了, 不论你如何修改 item, 都不会影响原数组了 上面所说的都是数组中的每个值都是对象的情况, 也可以试试值不是对象的数组, 比如基本类型, 那这样是无论如何也不会修改原数组了, 因为基本类型并没有地址值这一说, 只是将值赋给 item, 他们之间并没有关联关系 扩展 其实 forEach 和 map 的最大共同点就是都是函数, item 就相当于是形参, 我原来一直认为形参不会改变实参, 但其实并不是这样的, 类比上面结论可以得知: 如果实参是基本类型, 那确实改变不了实参; 如果实参是引用类型: 函数修改了形参的地址值或将其修改为基本类型, 改变不了实参 函数没有修改形参的地址值, 只是修改形参内部的某些属性, 会改变实参 12345arr2 = [1,&apos;str&apos;,false,undefined,null]arr2.forEach(item=&gt;&#123; item = 3&#125;)// arr2 值为[1,&apos;str&apos;,false,undefined,null]","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"},{"name":"数组操作","slug":"数组操作","permalink":"http://yoursite.com/tags/数组操作/"}]},{"title":"chrome 66版本自动播放策略","slug":"chrome 66版本自动播放策略","date":"2020-01-17T02:44:15.000Z","updated":"2020-11-13T03:06:53.058Z","comments":true,"path":"2020/01/17/chrome 66版本自动播放策略/","link":"","permalink":"http://yoursite.com/2020/01/17/chrome 66版本自动播放策略/","excerpt":"","text":"背景Web浏览器正在朝着更严格的自动播放策略发展，以便改善用户体验，最大限度地降低安装广告拦截器的积极性并减少昂贵和/或受限网络上的数据消耗。这些更改旨在为用户提供更大的播放控制权，并使开发商获得合法用例。 新的特性Chrome的自动播放政策很简单： 静音自动播放总是允许的。 在下列情况下允许使用声音自动播放： 用户已经与域进行了交互（点击，tap等）。 在桌面上，用户的媒体参与指数阈值(MEI)已被越过，这意味着用户以前播放带有声音的视频。 在移动设备上，用户已将该网站添加到主屏幕。 顶部框架可以将自动播放权限授予其iframe以允许自动播放声音。 媒体参与指数（Media Engagement Index)(MEI)MEI衡量个人在网站上消费媒体的倾向。Chrome 目前的方法是访问每个来源的重要媒体播放事件的比率： 媒体消耗（音频/视频）必须大于7秒。 音频必须存在并取消静音。 视频选项卡处于活动状态。 视频大小（以像素为单位）必须大于200x140。 因此，Chrome会计算媒体参与度分数，该分数在定期播放媒体的网站上最高。足够高时，媒体播放只允许在桌面上自动播放。MEI是谷歌自动播放策略的一部分。它是一个算法，参考了媒体内容的持续时间、浏览器标签页是否活动、活动标签页视频的大小这一系列元素。不过也正因此，开发者难以在所有的网页上都测试这一算法的效果。 用户的MEI位于chrome://media-engagement/内部页面 开发者开关作为开发者，您可能需要在本地更改Chrome浏览器自动播放政策行为，以根据用户的参与情况测试您的网站。 您可以决定通过将Chrome标志“自动播放策略”设置为“无需用户手势”来完全禁用自动播放策略 chrome://flags/#autoplay-policy。这样您就可以测试您的网站，就好像用户与您的网站保持紧密联系一样，并且始终允许播放自动播放。 您也可以决定禁止使用MEI以及默认情况下全新MEI获得播放自动播放的网站是否允许新用户使用，从而决定禁止播放自动播放。这可以用两个来完成 内部开关用chrome.exe –disable-features=PreloadMediaEngagementData,AutoplayIgnoreWebAudio, MediaEngagementBypassAutoplayPolicies Iframe 委托授权一个功能政策使开发人员可以选择性地启用和禁用的各种浏览器的功能和API。一旦来源获得了自动播放权限，它就可以将该权限委托给具有自动播放功能的跨源iframe 。默认情况下，同源iframe可以使用自动播放。 1234&lt;！ - 允许自动播放。- &gt; &lt;iframe src = &quot;https://cross-origin.com/myvideo.html&quot; allow = &quot;autoplay&quot; /&gt; &lt;！ - 允许自动播放和全屏播放。- &gt; &lt;iframe src = &quot;https://cross-origin.com/myvideo.html&quot; allow = &quot;autoplay; fullscreen&quot; /&gt; 当禁用自动播放的功能策略时，play()不带用户手势的调用将拒绝带有NotAllowedErrorDOMException 的promise。自动播放属性也将被忽略。 示例场景: 示例1：每次用户在他们的笔记本电脑上访问 www.iqiyi.com 时，他们都会观看电视节目或电影。由于其媒体参与度较高，因此可以自动播放。 示例2：www.iqiyi.com 同时具有文字和视频内容。大多数用户偶尔会去该网站获取文字内容并观看视频。用户的媒体参与度较低，因此如果用户直接从社交媒体页面或搜索导航，则不允许自动播放。 示例3：news.iqiyi.com 同时具有文字和视频内容。大多数人通过主页进入网站，然后点击新闻报道。由于用户与域名互动，新闻文章页面上的自动播放将被允许。但是，应该注意确保用户不会对自动播放内容感到意外。 示例4： 在爱奇艺泡泡页面将iframe与电影预告片一起嵌入其评论中。用户与域进行交互以访问特定的网站，因此允许自动播放。但是，泡泡需要将该特权显式委托给iframe以便内容自动播放。 Chrome企业政策Chrome企业策略可以改变这种新的自动播放行为，以用于例如信息亭或无人值守系统。查看 配置策略和设置帮助页面，了解如何设置这些新的与自动播放相关的企业策略： 该“AutoplayAllowed”策略控制自动播放是否允许。 该“AutoplayWhitelist”政策，允许您指定的URL模式的白名单，其中自动播放将始终启用。 开发人员最佳实践 视频元素 永远不要假设视频会播放，并且在视频不是真正播放时不要显示暂停按钮。 关注播放函数返回的Promise。 123456789var promise = document.querySelector(&apos;video&apos;).play();if (promise !== undefined) &#123; promise.then(_ =&gt; &#123; // Autoplay started! &#125;).catch(error =&gt; &#123; // Autoplay was prevented. // Show a &quot;Play&quot; button so that user can start playback. &#125;);&#125; 使用静音自动播放 12345678&lt;video id=&quot;video&quot; muted autoplay&gt;&lt;button id=&quot;unmuteButton&quot;&gt;&lt;/button&gt;&lt;script&gt; unmuteButton.addEventListener(&apos;click&apos;, function() &#123; video.muted = false; &#125;);&lt;/script&gt; 站点 处理方式 微博 静音开播 优酷 开播暂停 腾讯 部分静音开播部分暂停 爱奇艺 静音开播 部分暂停 B站 暂未处理 以上情况截止本文发表前部分页面统计不代表全部。 音频元素 原生播放音频除了使用audio标签之外，还有另外一个API叫AudioContext，AudioContext接口表示由音频模块连接而成的音频处理图，每个模块对应一个AudioNode。AudioContext可以控制它所包含的节点的创建，以及音频处理、解码操作的执行。做任何事情之前都要先创建AudioContext对象，因为一切都发生在这个环境之中。 AudioContext播放声音 1、先请求音频文件，放到ArrayBuffer里面，然后用AudioContext的API进行decode解码，解码完了再让它去play。 1234567891011121314function request (url) &#123; return new Promise (resolve =&gt; &#123; let xhr = new XMLHttpRequest(); xhr.open(&apos;GET&apos;, url); // set response Type arraybuffer xhr.responseType = &apos;arraybuffer&apos;; xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; resolve(xhr.response); &#125; &#125;; xhr.send(); &#125;);&#125; 2、实例化AudioContext12// Safari是使用webkit前缀let context = new (window.AudioContext || window.webkitAudioContext)(); 3、解码播放1234567891011function play (context, decodeBuffer) &#123; let source = context.createBufferSource(); source.buffer = decodeBuffer; source.connect(context.destination); // 从0s开始播放 source.start(0);&#125;// 请求音频数据let audioMedia = await request(url);// 进行decode和playcontext.decodeAudioData(audioMedia, decode =&gt; play(context, decode)); 关于音频播放的可以参阅这篇文章讲的比较详细，这里不再讨论。 AudioContext创建时机 页面加载时创建那么resume()在用户与页面进行交互之后（例如，用户单击按钮），您必须在某个时间进行调用。 12345678910111213// Existing code unchanged.window.onload = function() &#123; var context = new AudioContext(); // Setup all nodes ...&#125;// One-liner to resume playback when user interacted with the page.document.querySelector(&apos;button&apos;).addEventListener(&apos;click&apos;, function() &#123; context.resume().then(() =&gt; &#123; console.log(&apos;Playback resumed successfully&apos;); &#125;);&#125;); 在用户与该页面进行交互时创建。 123456document.querySelector(&apos;button&apos;).addEventListener(&apos;click&apos;, function() &#123; var context = new AudioContext(); // Setup all nodes ...&#125;); 参考资料https://developers.google.com/web/updates/2017/09/autoplay-policy-changes https://developers.google.com/web/updates/2016/07/autoplay https://github.com/WICG/feature-policy/blob/gh-pages/features.md https://wicg.github.io/feature-policy/ https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Audio_API/Using_Web_Audio_API https://segmentfault.com/a/1190000003115198 原文地址: https://github.com/gnipbao/iblog/issues/25","categories":[],"tags":[{"name":"video","slug":"video","permalink":"http://yoursite.com/tags/video/"},{"name":"chrome","slug":"chrome","permalink":"http://yoursite.com/tags/chrome/"}]},{"title":"记录一些viewprot知识点","slug":"记录一些viewprot知识点","date":"2019-06-26T11:19:28.000Z","updated":"2020-11-13T03:06:53.072Z","comments":true,"path":"2019/06/26/记录一些viewprot知识点/","link":"","permalink":"http://yoursite.com/2019/06/26/记录一些viewprot知识点/","excerpt":"","text":"移动前端开发之viewport的深入理解在移动设备上进行网页的重构或开发，首先得搞明白的就是移动设备上的viewport了，只有明白了viewport的概念以及弄清楚了跟viewport有关的meta标签的使用，才能更好地让我们的网页适配或响应各种不同分辨率的移动设备。 一、viewport的概念通俗的讲，移动设备上的viewport就是设备的屏幕上能用来显示我们的网页的那一块区域，在具体一点，就是浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域要大，也可能比浏览器的可视区域要小。在默认情况下，一般来讲，移动设备上的viewport都是要大于浏览器可视区域的，这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小，所以为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px或1024px（也可能是其它值，这个是由设备自己决定的），但带来的后果就是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。下图列出了一些设备上浏览器的默认viewport的宽度。 二、css中的1px并不等于设备的1px在css中我们一般使用px作为单位，在桌面浏览器中css的1个像素往往都是对应着电脑屏幕的1个物理像素，这可能会造成我们的一个错觉，那就是css中的像素就是设备的物理像素。但实际情况却并非如此，css中的像素只是一个抽象的单位，在不同的设备或不同的环境中，css中的1px所代表的设备物理像素是不同的。在为桌面浏览器设计的网页中，我们无需对这个津津计较，但在移动设备上，必须弄明白这点。在早先的移动设备中，屏幕像素密度都比较低，如iphone3，它的分辨率为320x480，在iphone3上，一个css像素确实是等于一个屏幕物理像素的。后来随着技术的发展，移动设备的屏幕像素密度越来越高，从iphone4开始，苹果公司便推出了所谓的Retina屏，分辨率提高了一倍，变成640x960，但屏幕尺寸却没变化，这就意味着同样大小的屏幕上，像素却多了一倍，这时，一个css像素是等于两个物理像素的。其他品牌的移动设备也是这个道理。例如安卓设备根据屏幕像素密度可分为ldpi、mdpi、hdpi、xhdpi等不同的等级，分辨率也是五花八门，安卓设备上的一个css像素相当于多少个屏幕物理像素，也因设备的不同而不同，没有一个定论。还有一个因素也会引起css中px的变化，那就是用户缩放。例如，当用户把页面放大一倍，那么css中1px所代表的物理像素也会增加一倍；反之把页面缩小一倍，css中1px所代表的物理像素也会减少一倍。关于这点，在文章后面的部分还会讲到。在移动端浏览器中以及某些桌面浏览器中，window对象有一个devicePixelRatio属性，它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素。css中的px就可以看做是设备的独立像素，所以通过devicePixelRatio，我们可以知道该设备上一个css像素代表多少个物理像素。例如，在Retina屏的iphone上，devicePixelRatio的值为2，也就是说1个css像素相当于2个物理像素。但是要注意的是，devicePixelRatio在不同的浏览器中还存在些许的兼容性问题，所以我们现在还并不能完全信赖这个东西，具体的情况可以看下这篇文章。 devicePixelRatio的测试结果： 三、PPK的关于三个viewport的理论 ppk大神对于移动设备上的viewport有着非常多的研究（第一篇，第二篇，第三篇），有兴趣的同学可以去看一下，本文中有很多数据和观点也是出自那里。ppk认为，移动设备上有三个viewport。首先，移动设备上的浏览器认为自己必须能让所有的网站都正常显示，即使是那些不是为移动设备设计的网站。但如果以浏览器的可视区域作为viewport的话，因为移动设备的屏幕都不是很宽，所以那些为桌面浏览器设计的网站放到移动设备上显示时，必然会因为移动设备的viewport太窄，而挤作一团，甚至布局什么的都会乱掉。也许有人会问，现在不是有很多手机分辨率都非常大吗，比如768x1024，或者1080x1920这样，那这样的手机用来显示为桌面浏览器设计的网站是没问题的吧？前面我们已经说了，css中的1px并不是代表屏幕上的1px，你分辨率越大，css中1px代表的物理像素就会越多，devicePixelRatio的值也越大，这很好理解，因为你分辨率增大了，但屏幕尺寸并没有变大多少，必须让css中的1px代表更多的物理像素，才能让1px的东西在屏幕上的大小与那些低分辨率的设备差不多，不然就会因为太小而看不清。所以在1080x1920这样的设备上，在默认情况下，也许你只要把一个div的宽度设为300多px（视devicePixelRatio的值而定），就是满屏的宽度了。回到正题上来，如果把移动设备上浏览器的可视区域设为viewport的话，某些网站就会因为viewport太窄而显示错乱，所以这些浏览器就决定默认情况下把viewport设为一个较宽的值，比如980px，这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了。ppk把这个浏览器默认的viewport叫做 layout viewport。这个layout viewport的宽度可以通过 document.documentElement.clientWidth 来获取。 然而，layout viewport 的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个viewport来代表 浏览器可视区域的大小，ppk把这个viewport叫做 visual viewport。visual viewport的宽度可以通过window.innerWidth 来获取，但在Android 2, Oprea mini 和 UC 8中无法正确获取。 现在我们已经有两个viewport了：layout viewport 和 visual viewport。但浏览器觉得还不够，因为现在越来越多的网站都会为移动设备进行单独的设计，所以必须还要有一个能完美适配移动设备的viewport。所谓的完美适配指的是，首先不需要用户缩放和横向滚动条就能正常的查看网站的所有内容；第二，显示的文字的大小是合适，比如一段14px大小的文字，不会因为在一个高密度像素的屏幕里显示得太小而无法看清，理想的情况是这段14px的文字无论是在何种密度屏幕，何种分辨率下，显示出来的大小都是差不多的。当然，不只是文字，其他元素像图片什么的也是这个道理。ppk把这个viewport叫做 ideal viewport，也就是第三个viewport——移动设备的理想viewport。 ideal viewport并没有一个固定的尺寸，不同的设备拥有有不同的ideal viewport。所有的iphone的ideal viewport宽度都是320px，无论它的屏幕宽度是320还是640，也就是说，在iphone中，css中的320px就代表iphone屏幕的宽度。 但是安卓设备就比较复杂了，有320px的，有360px的，有384px的等等，关于不同的设备ideal viewport的宽度都为多少，可以到http://viewportsizes.com去查看一下，里面收集了众多设备的理想宽度。 再总结一下：ppk把移动设备上的viewport分为layout viewport 、 visual viewport 和 ideal viewport 三类，其中的ideal viewport是最适合移动设备的viewport，ideal viewport的宽度等于移动设备的屏幕宽度，只要在css中把某一元素的宽度设为ideal viewport的宽度(单位用px)，那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为100%的效果。ideal viewport 的意义在于，无论在何种分辨率的屏幕下，那些针对ideal viewport 而设计的网站，不需要用户手动缩放，也不需要出现横向滚动条，都可以完美的呈现给用户。 四、利用meta标签对viewport进行控制移动设备默认的viewport是layout viewport，也就是那个比屏幕要宽的viewport，但在进行移动设备网站的开发时，我们需要的是ideal viewport。那么怎么才能得到ideal viewport呢？这就该轮到meta标签出场了。 我们在开发移动设备的网站时，最常见的的一个动作就是把下面这个东西复制到我们的head标签中：1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt; 该meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。也许允不允许用户缩放不同的网站有不同的要求，但让viewport的宽度等于设备的宽度，这个应该是大家都想要的效果，如果你不这样的设定的话，那就会使用那个比屏幕宽的默认viewport，也就是说会出现横向滚动条。 这个name为viewport的meta标签到底有哪些东西呢，又都有什么作用呢？ meta viewport 标签首先是由苹果公司在其safari浏览器中引入的，目的就是解决移动设备的viewport问题。后来安卓以及各大浏览器厂商也都纷纷效仿，引入对meta viewport的支持，事实也证明这个东西还是非常有用的。 在苹果的规范中，meta viewport 有6个属性(暂且把content中的那些东西称为一个个属性和值)，如下： width 设置layout viewport&nbsp; 的宽度，为一个正整数，或字符串\"width-device\" initial-scale 设置页面的初始缩放值，为一个数字，可以带小数 minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数 maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数 height 设置layout viewport&nbsp; 的高度，这个属性对我们并不重要，很少使用 user-scalable 是否允许用户进行缩放，值为\"no\"或\"yes\", no 代表不允许，yes代表允许 这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了。 此外，在安卓中还支持 target-densitydpi 这个私有属性，它表示目标设备的密度等级，作用是决定css中的1px代表多少物理像素 target-densitydpi&nbsp; 值可以为一个数值或 high-dpi 、 medium-dpi、 low-dpi、 device-dpi 这几个字符串中的一个 特别说明的是，当 target-densitydpi=device-dpi 时， css中的1px会等于物理像素中的1px。 因为这个属性只有安卓支持，并且安卓已经决定要废弃target-densitydpi 这个属性了，所以这个属性我们要避免进行使用 。 五、把当前的viewport宽度设置为 ideal viewport 的宽度要得到ideal viewport就必须把默认的layout viewport的宽度设为移动设备的屏幕宽度。因为meta viewport中的width能控制layout viewport的宽度，所以我们只需要把width设为width-device这个特殊的值就行了。 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; 下图是这句代码在各大移动端浏览器上的测试结果： 可以看到通过width=device-width，所有浏览器都能把当前的viewport宽度变成ideal viewport的宽度，但要注意的是，在iphone和ipad上，无论是竖屏还是横屏，宽度都是竖屏时ideal viewport的宽度。 这样的写法看起来谁都会做，没吃过猪肉，谁还没见过猪跑啊~，确实，我们在开发移动设备上的网页时，不管你明不明白什么是viewport，可能你只需要这么一句代码就够了。 可是你肯定不知道 1&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1&quot;&gt; 这句代码也能达到和前一句代码一样的效果，也可以把当前的的viewport变为 ideal viewport。 呵呵，傻眼了吧，因为从理论上来讲，这句代码的作用只是不对当前的页面进行缩放，也就是页面本该是多大就是多大。那为什么会有 width=device-width 的效果呢？ 要想清楚这件事情，首先你得弄明白这个缩放是相对于什么来缩放的，因为这里的缩放值是1，也就是没缩放，但却达到了 ideal viewport 的效果，所以，那答案就只有一个了，缩放是相对于 ideal viewport来进行缩放的，当对ideal viewport进行100%的缩放，也就是缩放值为1的时候，不就得到了 ideal viewport吗？事实证明，的确是这样的。下图是各大移动端的浏览器当设置了 后是否能把当前的viewport宽度变成 ideal viewport 的宽度的测试结果。 测试结果表明 initial-scale=1 也能把当前的viewport宽度变成 ideal viewport 的宽度，但这次轮到了windows phone 上的IE 无论是竖屏还是横屏都把宽度设为竖屏时ideal viewport的宽度。但这点小瑕疵已经无关紧要了。 但如果width 和 initial-scale=1同时出现，并且还出现了冲突呢？比如： 1&lt;meta name=&quot;viewport&quot; content=&quot;width=400, initial-scale=1&quot;&gt; width=400表示把当前viewport的宽度设为400px，initial-scale=1则表示把当前viewport的宽度设为ideal viewport的宽度，那么浏览器到底该服从哪个命令呢？是书写顺序在后面的那个吗？不是。当遇到这种情况时，浏览器会取它们两个中较大的那个值。例如，当width=400，ideal viewport的宽度为320时，取的是400；当width=400， ideal viewport的宽度为480时，取的是ideal viewport的宽度。（ps:在uc9浏览器中，当initial-scale=1时，无论width属性的值为多少，此时viewport的宽度永远都是ideal viewport的宽度） 最后，总结一下，要把当前的viewport宽度设为ideal viewport的宽度，既可以设置 width=device-width，也可以设置 initial-scale=1，但这两者各有一个小缺陷，就是iphone、ipad以及IE 会横竖屏不分，通通以竖屏的ideal viewport宽度为准。所以，最完美的写法应该是，两者都写上去，这样就 initial-scale=1 解决了 iphone、ipad的毛病，width=device-width则解决了IE的毛病： 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; 六、关于meta viewport的更多知识1、关于缩放以及initial-scale的默认值首先我们先来讨论一下缩放的问题，前面已经提到过，缩放是相对于ideal viewport来缩放的，缩放值越大，当前viewport的宽度就会越小，反之亦然。例如在iphone中，ideal viewport的宽度是320px，如果我们设置 initial-scale=2 ，此时viewport的宽度会变为只有160px了，这也好理解，放大了一倍嘛，就是原来1px的东西变成2px了，但是1px变为2px并不是把原来的320px变为640px了，而是在实际宽度不变的情况下，1px变得跟原来的2px的长度一样了，所以放大2倍后原来需要320px才能填满的宽度现在只需要160px就做到了。因此，我们可以得出一个公式： 123visual viewport宽度 = ideal viewport宽度 / 当前缩放值当前缩放值 = ideal viewport宽度 / visual viewport宽度 ps: visual viewport的宽度指的是浏览器可视区域的宽度。 大多数浏览器都符合这个理论，但是安卓上的原生浏览器以及IE有些问题。安卓自带的webkit浏览器只有在 initial-scale = 1 以及没有设置width属性时才是表现正常的，也就相当于这理论在它身上基本没用；而IE则根本不甩initial-scale这个属性，无论你给他设置什么，initial-scale表现出来的效果永远是1。 好了，现在再来说下initial-scale的默认值问题，就是不写这个属性的时候，它的默认值会是多少呢？很显然不会是1，因为当 initial-scale = 1 时，当前的layout viewport宽度会被设为 ideal viewport的宽度，但前面说了，各浏览器默认的 layout viewport宽度一般都是980啊，1024啊，800啊等等这些个值，没有一开始就是 ideal viewport的宽度的，所以 initial-scale的默认值肯定不是1。安卓设备上的initial-scale默认值好像没有方法能够得到，或者就是干脆它就没有默认值，一定要你显示的写出来这个东西才会起作用，我们不管它了，这里我们重点说一下iphone和ipad上的initial-scale默认值。 根据测试，我们可以在iphone和ipad上得到一个结论，就是无论你给layout viewpor设置的宽度是多少，而又没有指定初始的缩放值的话，那么iphone和ipad会自动计算initial-scale这个值，以保证当前layout viewport的宽度在缩放后就是浏览器可视区域的宽度，也就是说不会出现横向滚动条。比如说，在iphone上，我们不设置任何的viewport meta标签，此时layout viewport的宽度为980px，但我们可以看到浏览器并没有出现横向滚动条，浏览器默认的把页面缩小了。根据上面的公式，当前缩放值 = ideal viewport宽度 / visual viewport宽度，我们可以得出： 当前缩放值 = 320 / 980 也就是当前的initial-scale默认值应该是 0.33这样子。当你指定了initial-scale的值后，这个默认值就不起作用了。 总之记住这个结论就行了：在iphone和ipad上，无论你给viewport设的宽的是多少，如果没有指定默认的缩放值，则iphone和ipad会自动计算这个缩放值，以达到当前页面不会出现横向滚动条(或者说viewport的宽度就是屏幕的宽度)的目的。 2、动态改变meta viewport标签第一种方法 可以使用document.write来动态输出meta viewport标签，例如：1document.write(&apos;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;&apos;) 第二种方法 通过setAttribute来改变12345&lt;meta id=&quot;testViewport&quot; name=&quot;viewport&quot; content=&quot;width = 380&quot;&gt;&lt;script&gt;var mvp = document.getElementById(&apos;testViewport&apos;);mvp.setAttribute(&apos;content&apos;,&apos;width=480&apos;);&lt;/script&gt; 安卓2.3自带浏览器上的一个bug1234567891011&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;alert(document.documentElement.clientWidth); //弹出600，正常情况应该弹出320&lt;/script&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=600&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;alert(document.documentElement.clientWidth); //弹出320，正常情况应该弹出600&lt;/script&gt; 测试的手机ideal viewport 宽度为320px，第一次弹出的值是600,但这个值应该是第行meta标签的结果啊，然后第二次弹出的值是320，这才是第一行meta标签所达到的效果啊，所以在安卓2.3(或许是所有2.x版本中)的自带浏览器中，对meta viewport标签进行覆盖或更改，会出现让人非常迷糊的结果。 七、结语说了那么多废话，最后还是有必要总结一点有用的出来。 首先如果不设置meta viewport标签，那么移动设备上浏览器默认的宽度值为800px，980px，1024px等这些，总之是大于屏幕宽度的。这里的宽度所用的单位px都是指css中的px，它跟代表实际屏幕物理像素的px不是一回事。 第二、每个移动设备浏览器中都有一个理想的宽度，这个理想的宽度是指css中的宽度，跟设备的物理宽度没有关系，在css中，这个宽度就相当于100%的所代表的那个宽度。我们可以用meta标签把viewport的宽度设为那个理想的宽度，如果不知道这个设备的理想宽度是多少，那么用device-width这个特殊值就行了，同时initial-scale=1也有把viewport的宽度设为理想宽度的作用。所以，我们可以使用 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; 来得到一个理想的viewport（也就是前面说的ideal viewport）。为什么需要有理想的viewport呢？比如一个分辨率为320x480的手机理想viewport的宽度是320px，而另一个屏幕尺寸相同但分辨率为640x960的手机的理想viewport宽度也是为320px，那为什么分辨率大的这个手机的理想宽度要跟分辨率小的那个手机的理想宽度一样呢？这是因为，只有这样才能保证同样的网站在不同分辨率的设备上看起来都是一样或差不多的。实际上，现在市面上虽然有那么多不同种类不同品牌不同分辨率的手机，但它们的理想viewport宽度归纳起来无非也就 320、360、384、400等几种，都是非常接近的，理想宽度的相近也就意味着我们针对某个设备的理想viewport而做出的网站，在其他设备上的表现也不会相差非常多甚至是表现一样的。 转自：https://www.cnblogs.com/2050/p/3877280.html","categories":[],"tags":[{"name":"viewport","slug":"viewport","permalink":"http://yoursite.com/tags/viewport/"},{"name":"移动开发","slug":"移动开发","permalink":"http://yoursite.com/tags/移动开发/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"图片懒加载","slug":"图片懒加载","date":"2019-06-24T12:59:28.000Z","updated":"2020-11-13T03:06:53.067Z","comments":true,"path":"2019/06/24/图片懒加载/","link":"","permalink":"http://yoursite.com/2019/06/24/图片懒加载/","excerpt":"","text":"原理将页面中的img标签src指向一张小图片或者src为空，然后定义data-src（这个属性可以自定义命名，我才用data-src）属性指向真实的图片。src指向一张默认的图片，否则当src为空时也会向服务器发送一次请求。可以指向loading的地址。 1&lt;img src=&quot;default.jpg&quot; data-src=&quot;http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg&quot; /&gt; 当载入页面时，先把可视区域内的img标签的data-src属性值赋值给src，然后监听滚动事件，把用户即将看到的图片加载。这样便实现了懒加载。 代码在写代码前，需要了解各种高度。先看这篇文章https://link.zhihu.com/?target=http%3A//i.jakeyu.top/2016/09/04/scrollTop-offsetTop-scrollLeft-offsetLeft/ 1234567891011121314151617181920&lt;style&gt; img &#123; display: block; margin-bottom: 50px; width: 400px; height: 400px; &#125;&lt;/style&gt; &lt;img src=&quot;default.jpg&quot; data-src=&quot;http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;default.jpg&quot; data-src=&quot;http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;default.jpg&quot; data-src=&quot;http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;default.jpg&quot; data-src=&quot;http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;default.jpg&quot; data-src=&quot;http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;default.jpg&quot; data-src=&quot;http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;default.jpg&quot; data-src=&quot;http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;default.jpg&quot; data-src=&quot;http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;default.jpg&quot; data-src=&quot;http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;default.jpg&quot; data-src=&quot;http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;default.jpg&quot; data-src=&quot;http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg&quot; alt=&quot;&quot;&gt; JavaScript1234567891011121314151617var num = document.getElementsByTagName(&apos;img&apos;).length; var img = document.getElementsByTagName(&quot;img&quot;); var n = 0; //存储图片加载到的位置，避免每次都从第一张图片开始遍历 lazyload(); //页面载入完毕加载可是区域内的图片 window.onscroll = lazyload; function lazyload() &#123; //监听页面滚动事件 var seeHeight = document.documentElement.clientHeight; //可见区域高度 var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; //滚动条距离顶部高度 for (var i = n; i &lt; num; i++) &#123; if (img[i].offsetTop &lt; seeHeight + scrollTop) &#123; if (img[i].getAttribute(&quot;src&quot;) == &quot;default.jpg&quot;) &#123; img[i].src = img[i].getAttribute(&quot;data-src&quot;); &#125; n = i + 1; &#125; &#125; &#125; 使用节流函数进行性能优化如果直接将函数绑定在scroll事件上，当页面滚动时，函数会被高频触发，这非常影响浏览器的性能。 我想实现限制触发频率，来优化性能。 节流函数：只允许一个函数在N秒内执行一次。下面是一个简单的节流函数： 1234567891011121314151617181920212223242526// 简单的节流函数//fun 要执行的函数//delay 延迟//time 在time时间内必须执行一次function throttle(fun, delay, time) &#123; var timeout, startTime = new Date(); return function() &#123; var context = this, args = arguments, curTime = new Date(); clearTimeout(timeout); // 如果达到了规定的触发时间间隔，触发 handler if (curTime - startTime &gt;= time) &#123; fun.apply(context, args); startTime = curTime; // 没达到触发间隔，重新设定定时器 &#125; else &#123; timeout = setTimeout(fun, delay); &#125; &#125;;&#125;;// 实际想绑定在 scroll 事件上的 handlerfunction lazyload(event) &#123;&#125;// 采用了节流函数window.addEventListener(&apos;scroll&apos;,throttle(lazyload,500,1000));","categories":[],"tags":[],"author":"guoshengbo"},{"title":"原生js实现拖动改变div大小","slug":"原生js实现拖动改变div大小","date":"2019-03-01T08:29:54.000Z","updated":"2020-11-13T03:06:53.063Z","comments":true,"path":"2019/03/01/原生js实现拖动改变div大小/","link":"","permalink":"http://yoursite.com/2019/03/01/原生js实现拖动改变div大小/","excerpt":"","text":"业务需要左右拖动来实现不换行查看数组件全部内容，这里记载一下实现过程。 html部分：12345678&lt;div id=\"box\"&gt; &lt;div id=\"top\"&gt; &lt;/div&gt; &lt;div id=\"bottom\"&gt; &lt;/div&gt; &lt;div id=\"line\"&gt; &lt;/div&gt;&lt;/div&gt; css部分：123456#box&#123;position:relative;&#125;#box ul&#123;list-style-position:inside;margin:10px;&#125;#top,#bottom&#123;color:#FFF;&#125;#top&#123;float:left&#125;#bottom&#123;float:right&#125;#line&#123;position:absolute;top:0;left:241px;height:100%;width:4px;cursor:w-resize;&#125; js部分：12345678910111213141516171819202122232425262728function $(id) &#123; return document.getElementById(id)&#125;window.onload = function() &#123; var oBox = $(\"box\"), oTop = $(\"top\"), oBottom = $(\"bottom\"), oLine = $(\"line\"); oLine.onmousedown = function(e) &#123; var disX = (e || event).clientX; oLine.left = oLine.offsetLeft; document.onmousemove = function(e) &#123; var iT = oLine.left + ((e || event).clientX - disX); var e=e||window.event,tarnameb=e.target||e.srcElement; var maxT = oBox.clientWight - oLine.offsetWidth; oLine.style.margin = 0; iT &lt; 0 &amp;&amp; (iT = 0); iT &gt; maxT &amp;&amp; (iT = maxT); oLine.style.left = oTop.style.width = iT + \"px\"; oBottom.style.width = oBox.clientWidth - iT + \"px\"; return false &#125;; document.onmouseup = function() &#123; document.onmousemove = null; document.onmouseup = null; oLine.releaseCapture &amp;&amp; oLine.releaseCapture() &#125;; oLine.setCapture &amp;&amp; oLine.setCapture(); return false &#125;;&#125; 效果图：","categories":[],"tags":[]},{"title":"解决Element-ui-Tree组件无法出现横向滚动条","slug":"解决Element-ui-Tree组件无法出现横向滚动条","date":"2019-02-28T02:55:00.000Z","updated":"2020-11-13T03:06:53.068Z","comments":true,"path":"2019/02/28/解决Element-ui-Tree组件无法出现横向滚动条/","link":"","permalink":"http://yoursite.com/2019/02/28/解决Element-ui-Tree组件无法出现横向滚动条/","excerpt":"","text":"elementUI用到tree组件碰到tree节点过多需要横向滚动显示。但是组件文档上没有。 上github发现这个问题有人已经遇到而且提了issue 通过下面方法搞定 具体操作：1、在tree外包一层div,并设置父元素的高，这样才不会出现横向滚动条在树的最低端，需要滚动竖向滚动条才能看到。1234&lt;div class=\"tree\"&gt; &lt;el-tree&gt; &lt;/el-tree&gt; &lt;/div&gt; 2、定义tree的样式1234567.tree &#123; overflow-y: auto; overflow-x: scroll; width: 80px; height: 500px; background-color: #ffffff; &#125; 3、重写tree样式1234.el-tree &#123; min-width: 100%; display: inline-block !important; &#125; 4、设置以下属性，可以防止树多出了莫名的高度123.el-tree-node &gt; .el-tree-node__children &#123; overflow: visible;&#125; 最终实现效果","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"element","slug":"element","permalink":"http://yoursite.com/tags/element/"},{"name":"滚动条","slug":"滚动条","permalink":"http://yoursite.com/tags/滚动条/"}],"author":"guoshengbo"},{"title":"github生成SSH KEY","slug":"github生成SSH-KEY","date":"2019-02-27T09:56:28.000Z","updated":"2020-11-13T03:06:53.059Z","comments":true,"path":"2019/02/27/github生成SSH-KEY/","link":"","permalink":"http://yoursite.com/2019/02/27/github生成SSH-KEY/","excerpt":"","text":"由于本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以必须要让github仓库认证你SSH key，在此之前，必须要生成SSH key。 1、打开cmd，在控制台中输入以下命令。 1$ ssh-keygen -t rsa -C \"邮箱地址\" 密钥类型可以用 -t 选项指定。如果没有指定则默认生成用于SSH-2的RSA密钥。这里使用的是rsa。 同时在密钥中有一个注释字段，用-C来指定所指定的注释，可以方便用户标识这个密钥，指出密钥的用途或其他有用的信息。所以在这里输入自己的邮箱或者其他都行。 输入完毕后程序同时要求输入一个密语字符串(passphrase)，空表示没有密语。接着会让输入2次口令(password)，空表示没有口令。3次回车即可完成当前步骤，此时[c盘&gt;用户&gt;自己的用户名&gt;.ssh]目录下已经生成好了。 2、登录github。打开setting =&gt; SSH keys，点击右上角 New SSH key，把生成好的公钥id_rsa.pub放进 key输入框中，再为当前的key起一个title来区分每个key。","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"关于call、apply和bind的一些记录","slug":"关于call、apply和bind的一些记录","date":"2018-10-06T08:38:36.000Z","updated":"2020-11-13T03:06:53.061Z","comments":true,"path":"2018/10/06/关于call、apply和bind的一些记录/","link":"","permalink":"http://yoursite.com/2018/10/06/关于call、apply和bind的一些记录/","excerpt":"","text":"call、apply和bind是Function对象自带的三个方法，都是为了改变函数体内部 this 的指向。 apply 、 call 、bind 三者第一个参数都是 this 要指向的对象，也就是想指定的上下文； apply 、 call 、bind 三者都可以利用后续参数传参； bind 是返回对应 函数，便于稍后调用；apply 、call 则是立即调用 。 对于 apply、call 二者而言，作用完全一样，只是接受 参数 的方式不太一样。call 是把参数按顺序传递进去，而 apply 则是把参数放在数组 里。1234567var func = function(arg1, arg2) &#123; ...&#125;;func.call(this, arg1, arg2); // 使用 call，参数列表func.apply(this, [arg1, arg2]) // 使用 apply，参数数组 实际应用中使用场景：12345678910var vegetables = [&apos;parsnip&apos;, &apos;potato&apos;]var moreVegs = [&apos;celery&apos;, &apos;beetroot&apos;]// 将第二个数组融合进第一个数组// 相当于 vegetables.push(&apos;celery&apos;, &apos;beetroot&apos;)Array.prototype.push.apply(vegetables, moreVegs)// 4console.log(vegetables)// [&apos;parsnip&apos;, &apos;potato&apos;, &apos;celery&apos;, &apos;beetroot&apos;] 注意：当第二个数组(如示例中的 moreVegs )太大时不要使用这个方法来合并数组，因为一个函数能够接受的参数个数是有限制的。不同的引擎有不同的限制，JS核心限制在 65535，有些引擎会抛出异常，有些不抛出异常但丢失多余参数。bind() 方法。MDN 的解释是：bind() 方法会创建一个 新函数，称为绑定函数，当调用这个绑定函数时， 绑定函数会以创建它时传入 bind() 方法的第一个参数 作为 this，传入 bind() 方法的 第二个以及以后的参 数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。12345678910var bar = function()&#123; console.log(this.x);&#125;var foo = &#123; x:3&#125;bar(); // undefinedvar func = bar.bind(foo); //此时this已经指向了foo，但是用bind（）方法并不会立即执行，而是创建一个新函数，如果要直接调用的话 可以 bar.bind(foo)（）func(); // 3 注意：多次 bind() 是无效的。更深层次的原因， bind() 的实现，相当于使用函数在内部包了一个 call / apply ，第二次 bind() 相当于再包住第一次 bind() ,故第二次以后的 bind 是无法生效的。未完待续。。。","categories":[],"tags":[{"name":"this","slug":"this","permalink":"http://yoursite.com/tags/this/"},{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]},{"title":"Electron打包（windows版）","slug":"Electron打包参数配置","date":"2018-09-15T06:55:20.000Z","updated":"2020-11-13T03:06:53.058Z","comments":true,"path":"2018/09/15/Electron打包参数配置/","link":"","permalink":"http://yoursite.com/2018/09/15/Electron打包参数配置/","excerpt":"","text":"安装位置，自动更新，手动更新 一：引包：electron,electron-builder，electron-updater**npm i electron –save-dev npm i electron-builder –save-dev npm i electron-updater –save 注：每个包都要放在相应的位置；Package.json配置： 1.字段：”build”参数：1234567891011121314151617181920212223&#123; &quot;publish&quot;: [ &#123; &quot;provider&quot;: &quot;generic&quot;, &quot;url&quot;: &quot;http://localhost:8899/&quot; //存放软件版本的地址 &#125; ], &quot;directories&quot;: &#123; &quot;output&quot;: &quot;release&quot;, //打包后文件所在位置 &quot;app&quot;: &quot;./&quot; //开始位置 &#125;, &quot;win&quot;: &#123; //windows下安装软件配置参数 &quot;target&quot;: [ &quot;nsis&quot;, //打包为nsis安装文件 &quot;zip&quot; //打包为安装文件zip ] &#125;, &quot;nsis&quot;: &#123; //nsis配置参数 &quot;oneClick&quot;: false, //可单击打开 &quot;allowToChangeInstallationDirectory&quot;: true, //允许用户选择安装位置 &quot;perMachine&quot;: true &#125;&#125;； 2.字段：”script”参数：1234&#123; &quot;dist&quot;: &quot;electron-builder&quot;&#125; 3.字段：”version”参数：11.0.0 //保存版本信息，通过该字段完成更新功能（必须字段） 二：打包：npm run dist等待打包，打包完成之后生成的文件会放在output字段设置的位置； 这是打包完成后生成的文件，其中latest.yml是electron-builder自动生成的版本管理文件， 该文件保存有版本信息； 箭头指向的文件为可安装软件，即打包后的目标文件； 版本文件： 可以看到，现在打包的版本为2.0.0，想要改变版本只要更改package.json的version字段，重新打包即可； 点击该文件可进行安装： 三：更新确认已经安装了electron-updater1234567891011121314151617181.需要在electron主进程中引入electron-updater；const autoUpdater = require(&quot;electron-updater&quot;).autoUpdater; //引入 autoUpdater2.以下代码需要在完成创建BrowserWindow后执行；autoUpdater.setFeedURL(&apos;http://localhost:8899/&apos;); //设置检测更新地址（参数为 软件所在位置）3.autoUpdater.checkForUpdates() //检测是否有新版本,如果有新版本则自动下载；4.autoUpdater.on(&apos;update-downloaded&apos;, function () &#123; //下载完成后执行 quitAndInstallautoUpdater.quitAndInstall(); //关闭软件并安装新版本&#125;);5.安装程序后，每次打开都会执行上述代码，每次都会检测是否有新版本；6.最后一步，打包一个新版本的软件，把exe文件和latest.yml一起放在autoUpdater.setFeedURL()设置的路径下； 打开软件后检测到有新版本时就会自动下载安装： 以上为软件自动更新，若要软件手动更新还需要electron主进程和渲染进程之间的通讯，通过用户操作触发更新检测，下载更新事件； 以下是autoUpdater手动更新时可能用到的方法和事件；123456789101112131415161718192021222324252627282930事件列表autoUpdater 对象会触发以下的事件： 事件：&apos;error&apos; 返回： error Error 当更新发生错误的时候触发。 事件：&apos;checking-for-update&apos; 当开始检查更新的时候触发。 事件：&apos;update-available&apos; 当发现一个可用更新的时候触发，更新包下载会自动开始。 事件：&apos;update-not-available&apos; 当没有可用更新的时候触发。 事件：&apos;update-downloaded&apos; 返回： event Event releaseNotes String - 新版本更新公告 releaseName String - 新的版本号 releaseDate Date - 新版本发布的日期 updateURL String - 更新地址 在更新下载完成的时候触发。 在 Windows 上只有 releaseName 是有效的。方法列表 autoUpdater 对象有以下的方法： autoUpdater.setFeedURL(url) url String 设置检查更新的 url，并且初始化自动更新。这个 url 一旦设置就无法更改。 autoUpdater.checkForUpdates() 向服务端查询现在是否有可用的更新。在调用这个方法之前，必须要先调用 setFeedURL。 autoUpdater.quitAndInstall() 在下载完成后，重启当前的应用并且安装更新。这个方法应该仅在 update-downloaded 事件触发后被调用。","categories":[],"tags":[{"name":"electron node.js","slug":"electron-node-js","permalink":"http://yoursite.com/tags/electron-node-js/"}]},{"title":"vsCode 自动格式化文件 并使用Eslint","slug":"vsCode-自动格式化文件-并使用Eslint","date":"2018-04-02T02:09:35.000Z","updated":"2020-11-13T03:06:53.060Z","comments":true,"path":"2018/04/02/vsCode-自动格式化文件-并使用Eslint/","link":"","permalink":"http://yoursite.com/2018/04/02/vsCode-自动格式化文件-并使用Eslint/","excerpt":"","text":"1、安装插件 1）ESlint：javascript代码检测工具，可以配置每次保存时格式化js，但每次保存只格式化一点点，你得连续按住Ctrl+S好几次,才格式化好，自行体会~~ 2）vetur：可以格式化html、标准css（有分号 、大括号的那种）、标准js（有分号 、双引号的那种）、vue文件， 3）Prettier - Code formatter：只关注格式化，并不具有eslint检查语法等能力，只关心格式化文件(最大长度、混合标签和空格、引用样式等)，包括JavaScript · Flow · TypeScript · CSS · SCSS · Less · JSX · Vue · GraphQL · JSON · Markdown 4）Manta’s Stylus Supremacy： 格式化stylus的插件（不用就不装），因为vetur会把css格式化有分号 、大括号的那种，此插件会把css格式化成stylus风格 2、在vscode的文件-首选项-设置-工作区设置-拓展-Eslint，从此直接 Ctrl+S 就能一键格式化了 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; // vscode默认启用了根据文件类型自动设置tabsize的选项 &quot;editor.detectIndentation&quot;: false, // 重新设定tabsize &quot;editor.tabSize&quot;: 2, // #每次保存的时候自动格式化 &quot;editor.formatOnSave&quot;: true, // #每次保存的时候将代码按eslint格式进行修复 &quot;eslint.autoFixOnSave&quot;: true, // 添加 vue 支持 &quot;eslint.validate&quot;: [ &quot;javascript&quot;, &quot;javascriptreact&quot;, &#123; &quot;language&quot;: &quot;vue&quot;, &quot;autoFix&quot;: true &#125; ], // #让prettier使用eslint的代码格式进行校验 &quot;prettier.eslintIntegration&quot;: true, // #去掉代码结尾的分号 &quot;prettier.semi&quot;: false, // #使用带引号替代双引号 &quot;prettier.singleQuote&quot;: true, // #让函数(名)和后面的括号之间加个空格 &quot;javascript.format.insertSpaceBeforeFunctionParenthesis&quot;: true, // #这个按用户自身习惯选择 &quot;vetur.format.defaultFormatter.html&quot;: &quot;js-beautify-html&quot;, // #让vue中的js按编辑器自带的ts格式进行格式化 &quot;vetur.format.defaultFormatter.js&quot;: &quot;vscode-typescript&quot;, &quot;vetur.format.defaultFormatterOptions&quot;: &#123; &quot;js-beautify-html&quot;: &#123; &quot;wrap_attributes&quot;: &quot;force-aligned&quot; // #vue组件中html代码格式化样式 &#125; &#125;, // 格式化stylus, 需安装Manta&apos;s Stylus Supremacy插件 &quot;stylusSupremacy.insertColons&quot;: false, // 是否插入冒号 &quot;stylusSupremacy.insertSemicolons&quot;: false, // 是否插入分好 &quot;stylusSupremacy.insertBraces&quot;: false, // 是否插入大括号 &quot;stylusSupremacy.insertNewLineAroundImports&quot;: false, // import之后是否换行 &quot;stylusSupremacy.insertNewLineAroundBlocks&quot;: false // 两个选择器中是否换行&#125;","categories":[],"tags":[],"author":"guoshengbo"}]}